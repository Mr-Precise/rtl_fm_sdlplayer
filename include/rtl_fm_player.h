/*
 * rtl_fm_player, turns your Realtek RTL2832 based DVB dongle into a SDR receiver
 * Based on rtl_fm_streamer by Albrecht Lohoefener
 * Based on "rtl_fm", see http://sdr.osmocom.org/trac/wiki/rtl-sdr for details
 *
 * Copyright (C) 2012 by Steve Markgraf <steve@steve-m.de>
 * Copyright (C) 2012 by Hoernchen <la@tfc-server.de>
 * Copyright (C) 2012 by Kyle Keen <keenerd@gmail.com>
 * Copyright (C) 2013 by Elias Oenal <EliasOenal@gmail.com>
 * Copyright (C) 2015 by Miroslav Slugen <thunder.m@email.cz>
 * Copyright (C) 2015 by Albrecht Lohoefener <albrechtloh@gmx.de>
 * Copyright (C) 2020 by Rafael Ferrari <rafaelbf@hotmail.com>
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 */

#include "rtl-sdr.h"

#define DEFAULT_SAMPLE_RATE		240000
#define DEFAULT_BUF_LENGTH		(1 * 16384)
#define MAXIMUM_OVERSAMPLE		16
#define MAXIMUM_BUF_LENGTH		(MAXIMUM_OVERSAMPLE * DEFAULT_BUF_LENGTH)
#define AUTO_GAIN				100
#define BUFFER_DUMP				4096

#define FREQUENCIES_LIMIT		1000

#define PI2_F           6.28318531f
#define PI_F            3.14159265f
#define PI_2_F          1.5707963f
#define PI_4_F          0.78539816f

#define DEEMPHASIS_NONE         0
#define DEEMPHASIS_FM_EU        0.000050
#define DEEMPHASIS_FM_USA       0.000075


// circular buffer for timeshift
char * circbuffer;
static volatile int circbuffeshift;
static volatile int circbufferslots;
#define CIRCBUFFCLUSTER 16384

static volatile int beverbose = 0;

static volatile int do_exit = 0;
static int lcm_post[17] =
{ 1, 1, 1, 3, 1, 5, 3, 7, 1, 9, 5, 11, 3, 13, 7, 15, 1 };
static int ACTUAL_BUF_LENGTH;


/* 8 MB */
static char input_buffer[16 * MAXIMUM_BUF_LENGTH];
static char output_buffer[16 * MAXIMUM_BUF_LENGTH];
uint32_t input_buffer_rpos = 0,
         input_buffer_wpos = 0,
         input_buffer_size = 0,
         input_buffer_size_max = 16 * MAXIMUM_BUF_LENGTH;
uint32_t output_buffer_rpos = 0,
         output_buffer_wpos = 0,
         output_buffer_size = 0,
         output_buffer_size_max = 16 * MAXIMUM_BUF_LENGTH;

// win32 libzplay dll
ZPLAY_HANDLE libzplay;

typedef enum
{
    false = 0,
    true
}bool;



bool isStartStream;


struct lp_real
{
	float *br;
	float *bm;
	float *bs;
	float *fm;
	float *fp;
	float *fs;
	float swf;
	float cwf;
	float pp;
	int pos;
	int size;
	int rsize;
	int mode;
};

struct dongle_state
{
	int exit_flag;
	pthread_t thread;
	rtlsdr_dev_t *dev;
	int dev_index;
	uint32_t freq;
	uint32_t rate;
	int gain;
	int ppm_error;
	int direct_sampling;
	int mute;
	struct demod_state *demod_target;
};

struct demod_state
{
	int exit_flag;
	pthread_t thread;
	uint8_t buf[MAXIMUM_BUF_LENGTH];
	uint32_t buf_len;
	/* required 4 bytes for F32 part */
	int16_t lowpassed[MAXIMUM_BUF_LENGTH << 1];
	int lp_len;
	/* tmp buffer for low pass filter F32 */
	float lowpass_tb[48];
	int16_t lp_i_hist[10][6];
	int16_t lp_q_hist[10][6];
	/* result buffer fo FM will be always 1/2 of lowpassed or less, so no need to shift */
	int16_t result[MAXIMUM_BUF_LENGTH];
	int result_len;
	int16_t droop_i_hist[9];
	int16_t droop_q_hist[9];
	int offset_tuning;
	int rate_in;
	int rate_out;
	int rate_out2;
	int now_r, now_j;
	int pre_r, pre_j;
	float pre_r_f32, pre_j_f32;
	int prev_index;
	int downsample; /* min 1, max 256 */
	int post_downsample;
	int output_scale;
	int squelch_level, conseq_squelch, squelch_hits, terminate_on_squelch;
	int downsample_passes;
	int comp_fir_size;
	int custom_atan;
	double deemph;
	int deemph_a;
	int deemph_l;
	int deemph_r;
	float deemph_l_f32;
	float deemph_r_f32;
	float deemph_lambda;
	float volume;
	int now_lpr;
	int prev_lpr_index;
	struct lp_real lpr;
	pthread_rwlock_t rw;
	pthread_cond_t ready;
	pthread_mutex_t ready_m;
	struct output_state *output_target;
};

struct output_state
{
	int exit_flag;
	pthread_t thread;
//	FILE *file;
	char *filename;
	int rate;
	int16_t *result;
	int result_len;
	pthread_rwlock_t rw;
	pthread_cond_t ready;
	pthread_mutex_t ready_m;
};

struct controller_state
{
	int exit_flag;
	pthread_t thread;
	uint32_t freqs[FREQUENCIES_LIMIT];
	int freq_len;
	int freq_now;
	int edge;
	int wb_mode;
	pthread_cond_t hop;
	pthread_mutex_t hop_m;
};


float RMSShadowBuf[MAXIMUM_BUF_LENGTH << 1];
int RMSShadowBuf_len;


// multiple of these, eventually
struct dongle_state dongle;
struct demod_state demod;
struct output_state output;
struct controller_state controller;


  static const char WAVHeaderStereo[] = {
	0x52, 0x49, 0x46, 0x46, 0x24, 0xEE, 0x02, 0x00, 0x57, 0x41, 0x56, 0x45, 0x66, 0x6D, 0x74, 0x20, 
	0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x02, 0x00, 0x80, 0xBB, 0x00, 0x00, 0x00, 0xEE, 0x02, 0x00, 
	0x04, 0x00, 0x10, 0x00, 0x64, 0x61, 0x74, 0x61, 0x00, 0xEE, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00};
    

  static const char WAVHeaderMono[] = {
	0x52, 0x49, 0x46, 0x46, 0x24, 0x77, 0x01, 0x00, 0x57, 0x41, 0x56, 0x45, 0x66, 0x6D, 0x74, 0x20, 
	0x10, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x80, 0xBB, 0x00, 0x00, 0x00, 0x77, 0x01, 0x00, 
	0x02, 0x00, 0x10, 0x00, 0x64, 0x61, 0x74, 0x61, 0x00, 0x77, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
	0x00, 0x00, 0x00, 0x00};    

/* {length, coef, coef, coef}  and scaled by 2^15
 for now, only length 9, optimal way to get +85% bandwidth */
#define CIC_TABLE_MAX 10
int cic_9_tables[][10] =
{
{ 0, },
{ 9, -156, -97, 2798, -15489, 61019, -15489, 2798, -97, -156 },
{ 9, -128, -568, 5593, -24125, 74126, -24125, 5593, -568, -128 },
{ 9, -129, -639, 6187, -26281, 77511, -26281, 6187, -639, -129 },
{ 9, -122, -612, 6082, -26353, 77818, -26353, 6082, -612, -122 },
{ 9, -120, -602, 6015, -26269, 77757, -26269, 6015, -602, -120 },
{ 9, -120, -582, 5951, -26128, 77542, -26128, 5951, -582, -120 },
{ 9, -119, -580, 5931, -26094, 77505, -26094, 5931, -580, -119 },
{ 9, -119, -578, 5921, -26077, 77484, -26077, 5921, -578, -119 },
{ 9, -119, -577, 5917, -26067, 77473, -26067, 5917, -577, -119 },
{ 9, -199, -362, 5303, -25505, 77489, -25505, 5303, -362, -199 }, };


/* table for u8 -> f32 conversion, 0 = positive, 1 = negative */
static float u8_f32_table[2][256] =
{
{ 0 },
{ 0 } };

/* table with low pass filter coeficients */
static float lp_filter_f32[16] =
{ 0 };
